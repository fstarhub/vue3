<!--
 * @Description: 
 * @Version: 3.0
 * @Autor: 冯帅
 * @Date: 2021-07-13 19:34:51
 * @LastEditors: 冯帅
 * @LastEditTime: 2021-07-18 16:35:08
-->
## 原型
1. 为什么 typeof 判断 null 是 Object 类型？
2. Function 和 Object 是什么关系？
3. new 关键字具体做了什么？手写实现。
4. prototype 和__proto__是什么关系？什么情况下相等？
5. ES5 实现继承有几种方式，优缺点是啥
6. ES6 如何实现一个类
7. ES6 extends 关键字实现原理是什么

![原型图](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F939316%2F201809%2F939316-20180927095306645-1975780154.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1628769155&t=dde49164112636162fa9b36cfbfd9ede)

* function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等
* function Object 就是一个 Object
* function Function 就是 Function
* 以上都是 function，所以 .__proto__都是Function.prototype
* 再次强调，String、Array、Number、Function、Object都是 function

### 函数对象和普通对象
老话说，万物皆对象。而我们都知道在 JavaScript 中，创建对象有好几种方式，比如对象字面量，或者直接通过构造函数 new 一个对象出来：

**都是对象，却存在着差异性**

其实在 JavaScript 中，我们将对象分为函数对象和普通对象。**所谓的函数对象，其实就是 JavaScript 的用函数来模拟的类实现**。JavaScript 中的 Object 和 Function 就是典型的函数对象。

```js
  function fun1(){};
  const fun2 = function(){};
  const fun3 = new Function('name','console.log(name)');

  const obj1 = {};
  const obj2 = new Object();
  const obj3 = new fun1();
  const obj4 = new new Function();


  console.log(typeof Object);//function
  console.log(typeof Function);//function
  console.log(typeof fun1);//function
  console.log(typeof fun2);//function
  console.log(typeof fun3);//function
  console.log(typeof obj1);//object
  console.log(typeof obj2);//object
  console.log(typeof obj3);//object
  console.log(typeof obj4);//object
```

上述代码中，obj1，obj2，obj3，obj4都是普通对象，fun1，fun2，fun3 都是 Function 的实例，也就是函数对象

所以可以看出，所有 Function 的实例都是函数对象，其他的均为普通对象，其中包括 Function 实例的实例。

![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4623fc5be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


**JavaScript 中万物皆对象，而对象皆出自构造（构造函数）。**

上图中，你疑惑的点是不是 **Function 和 new Function 的关系**。其实是这样子的：

`Function.__proto__ === Function.prototype//true`

```js
  Number.__proto__ === Function.prototype  // true
  Number.constructor == Function //true

  Boolean.__proto__ === Function.prototype // true
  Boolean.constructor == Function //true

  String.__proto__ === Function.prototype  // true
  String.constructor == Function //true

  // 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
  Object.__proto__ === Function.prototype  // true
  Object.constructor == Function // true

  // 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
  Function.__proto__ === Function.prototype // true
  Function.constructor == Function //true

  Array.__proto__ === Function.prototype   // true
  Array.constructor == Function //true

  RegExp.__proto__ === Function.prototype  // true
  RegExp.constructor == Function //true

  Error.__proto__ === Function.prototype   // true
  Error.constructor == Function //true

  Date.__proto__ === Function.prototype    // true
  Date.constructor == Function //true
```
JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的proto是Object.prototype。如下

```js
  Math.__proto__ === Object.prototype  // true
  Math.construrctor == Object // true

  JSON.__proto__ === Object.prototype  // true
  JSON.construrctor == Object //true
```
上面说的函数对象当然包括自定义的。如下
```js
  // 函数声明
  function Person() {}
  // 函数表达式
  var Perosn = function() {}
  console.log(Person.__proto__ === Function.prototype) // true
  console.log(Man.__proto__ === Function.prototype)    // true
```
**所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind**

Function.prototype也是唯一一个typeof XXX.prototype为 function的prototype。其它的构造器的prototype都是一个对象

```js
  console.log(typeof Function.prototype) // function
  console.log(typeof Object.prototype)   // object
  console.log(typeof Number.prototype)   // object
  console.log(typeof Boolean.prototype)  // object
  console.log(typeof String.prototype)   // object
  console.log(typeof Array.prototype)    // object
  console.log(typeof RegExp.prototype)   // object
  console.log(typeof Error.prototype)    // object
  console.log(typeof Date.prototype)     // object
  console.log(typeof Object.prototype)   // object
```

上面还提到它是一个空的函数，console.log(Function.prototype)

知道了所有构造器（含内置及自定义）的__proto__都是Function.prototype，那Function.prototype的__proto__是谁呢？
相信都听说过**JavaScript中函数也是一等公民**，那从哪能体现呢？如下 

`console.log(Function.prototype.__proto__ === Object.prototype) // true`

这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。

**最后Object.prototype的proto是谁？**
`Object.prototype.__proto__ === null // true`
**已经到顶了，为null**

#### __proto__
> 首先我们需要明确两点：
1️、 **__proto__和constructor是对象独有的。**
2、  **prototype属性是函数独有的**

**但是在 JavaScript 中，函数也是对象，所以函数也拥有__proto__和 constructor属性。**

**__proto__属性既不能被 for in 遍历出来，也不能被 Object.keys(obj) 查找出来。**

访问对象的 obj.__proto__ 属性，默认走的是 Object.prototype 对象上 __proto__ 属性的 get/set 方法。
```js
  Object.defineProperty(Object.prototype,'__proto__',{
    get(){
      console.log('get')
    }
  });

  ({}).__proto__;
  console.log((new Object()).__proto__);
```

这里我们需要知道的是，**__proto__是对象所独有的，并且__proto__是一个对象指向另一个对象**，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的__proto__属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的__proto__属性所指向的父类的父类上去查找。以此类推，知道找到 null。而这个查找的过程，也就构成了我们常说的**原型链**。

#### prototype
在规范里，prototype 被定义为：给其它对象提供共享属性的对象。prototype 自己也是对象，只是被用以承担某个职能罢了.

所有对象，都可以作为另一个对象的 prototype 来用。

![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4956afb78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

修改__proto__的关系图，我们添加了 prototype,**prototype是函数所独有的**，它的作用就是包含可以给**特定类型的所有实例提供共享的属性和方法**。它的含义就是函数的远行对象,正如上图：nealyang.__proto__ === Person.prototype。 任何函数在创建的时候，都会默认给该函数添加 prototype 属性.

#### constructor
**constructor属性也是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数。**

注意，**每一个对象都有其对应的构造函数，本身或者继承而来。单从constructor这个属性来讲，只有prototype对象才有**。每个函数在创建的时候，JavaScript 会同时创建一个该函数对应的prototype对象，**而函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其对应的构造函数。**

唯一特殊的可能就是我开篇抛出来的一个问题。**JavaScript 原型的老祖宗：Function。它是它自己的构造函数。所以Function.prototype === Function.__proto__。**

![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4a315ac95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

其中 constructor 属性，**虚线表示继承而来的 constructor 属性**

### typeof && instanceof 原理
[MDN文档typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)

#### 基本用法
一般被用于来判断一个变量的类型。我们**可以使用 typeof 来判断number、undefined、symbol、string、function、boolean、object 这七种数据类型**。但是遗憾的是，typeof 在判断 object 类型时候，有些许的尴尬。它并不能明确的告诉你，该 object 属于哪一种 object。

```js
  let s = new String('abc');
  let k = [1,3]
  typeof k === 'object' // true
  typeof s === 'object'// true
  typeof null;//"object"
```

#### 原理浅析
要想弄明白为什么 typeof 判断 null 为 object，其实需要从js 底层如何存储变量类型来说其。虽然说，这是 JavaScript 设计的一个 bug。

在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 "object"。曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但**被拒绝了**。该提案会导致 typeof null === 'null'。

js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息：

* 1：整数
* 110：布尔
* 100：字符串
* 010：浮点数
* 000：对象

但是，对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的：

* null：所有机器码均为0
* undefined：用 −2^30 整数来表示

所以在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。

#### instanceof
instanceof 和 typeof 非常的类似。**instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上**。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。

#### 基本用法

```js
  // 定义构造函数
  function C(){} 
  function D(){} 

  var o = new C();


  o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype


  o instanceof D; // false，因为 D.prototype 不在 o 的原型链上

  o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
  C.prototype instanceof Object // true，同上

  C.prototype = {};
  var o2 = new C();

  o2 instanceof C; // true

  o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.

  D.prototype = new C(); // 继承
  var o3 = new D();
  o3 instanceof D; // true
  o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上
```

如上，是 **instanceof 的基本用法，它可以判断一个实例是否是其父类型或者祖先类型的实例。**

```js
  console.log(Object instanceof Object);//true 
  console.log(Function instanceof Function);//true 
  console.log(Number instanceof Number);//false 
  console.log(String instanceof String);//false 

  console.log(Function instanceof Object);//true 

  console.log(Foo instanceof Function);//true 
  console.log(Foo instanceof Foo);//false
```
为什么 Object 和 Function instanceof 自己等于 true，而其他类 instanceof 自己却又不等于 true 呢？如何解释？
要想从根本上了解 instanceof 的奥秘，需要从两个方面着手：
1. 语言规范中是如何定义这个运算符的。
2. JavaScript 原型继承机制。

#### 原理浅析
经过上述的分析，相比大家对这种经典神图已经不那么陌生了吧，那咱就对着这张图来聊聊 instanceof

![原型图](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F939316%2F201809%2F939316-20180927095306645-1975780154.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1628769155&t=dde49164112636162fa9b36cfbfd9ede)

这里，我直接将规范定义翻译为 JavaScript 代码如下：
```js
  function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
  var O = R.prototype;// 取 R 的显示原型
  L = L.__proto__;// 取 L 的隐式原型
  while (true) { 
    if (L === null) 
      return false; 
    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true 
      return true; 
    L = L.__proto__; 
  } 
  }
```

所以如上原理，加上上文解释的原型相关知识，我们再来解析下为什么Object 和 Function instanceof 自己等于 true。

* Object instanceof Object
```js
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  ObjectL = Object, ObjectR = Object; 
  // 下面根据规范逐步推演
  O = ObjectR.prototype = Object.prototype 
  L = ObjectL.__proto__ = Function.prototype 
  // 第一次判断
  O != L 
  // 循环查找 L 是否还有 __proto__ 
  L = Function.prototype.__proto__ = Object.prototype 
  // 第二次判断
  O == L 
  // 返回 true
```

* Function instanceof Function
```js
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  FunctionL = Function, FunctionR = Function; 
  // 下面根据规范逐步推演
  O = FunctionR.prototype = Function.prototype 
  L = FunctionL.__proto__ = Function.prototype 
  // 第一次判断
  O == L 
  // 返回 true
```

* Foo instanceof Foo
```js
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  FooL = Foo, FooR = Foo; 
  // 下面根据规范逐步推演
  O = FooR.prototype = Foo.prototype 
  L = FooL.__proto__ = Function.prototype 
  // 第一次判断
  O != L 
  // 循环再次查找 L 是否还有 __proto__ 
  L = Function.prototype.__proto__ = Object.prototype 
  // 第二次判断
  O != L 
  // 再次循环查找 L 是否还有 __proto__ 
  L = Object.prototype.__proto__ = null 
  // 第三次判断
  L == null 
  // 返回 false
```

### ES5 中的继承实现方式
在继承实现上，工业聚大大在他的原型文章中，将原型继承分为两大类，显式继承和隐式继承。感兴趣的可以点击文末参考链接查看。

#### new 关键字
一个例子看下new 关键字都干了啥

```js
  function Person(name,age){
    this.name = name;
    this.age = age;
    
    this.sex = 'male';
  }

  Person.prototype.isHandsome = true;

  Person.prototype.sayName = function(){
    console.log(`Hello , my name is ${this.name}`);
  }

  let handsomeBoy = new Person('Nealyang',25);

  console.log(handsomeBoy.name) // Nealyang
  console.log(handsomeBoy.sex) // male
  console.log(handsomeBoy.isHandsome) // true

  handsomeBoy.sayName(); // Hello , my name is Nealyang
```
从上面的例子我们可以看到：
* 访问到 Person 构造函数里的属性
* 访问到 Person.prototype 中的属性

##### new 手写版本一
```js
  function objectFactory() {

      const obj = new Object(),//从Object.prototype上克隆一个对象

      Constructor = [].shift.call(arguments);//取得外部传入的构造器

      const F=function(){};
      F.prototype= Constructor.prototype;
      obj=new F();//指向正确的原型

      Constructor.apply(obj, arguments);//借用外部传入的构造器给obj设置属性

      return obj;//返回 obj
  };
```
* 用new Object() 的方式新建了一个对象 obj
* 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
* 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性
* 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性
* 返回 obj

下面我们来测试一下：
```js
  function Person(name,age){
    this.name = name;
    this.age = age;
    
    this.sex = 'male';
  }

  Person.prototype.isHandsome = true;

  Person.prototype.sayName = function(){
    console.log(`Hello , my name is ${this.name}`);
  }

  function objectFactory() {

      let obj = new Object(),//从Object.prototype上克隆一个对象

      Constructor = [].shift.call(arguments);//取得外部传入的构造器
      
      console.log({Constructor})

      const F=function(){};
      F.prototype= Constructor.prototype;
      obj=new F();//指向正确的原型

      Constructor.apply(obj, arguments);//借用外部传入的构造器给obj设置属性

      return obj;//返回 obj

  };

  let handsomeBoy = objectFactory(Person,'Nealyang',25);

  console.log(handsomeBoy.name) // Nealyang
  console.log(handsomeBoy.sex) // male
  console.log(handsomeBoy.isHandsome) // true

  handsomeBoy.sayName(); // Hello , my name is Nealyang
```
注意上面我们没有直接修改 obj 的__proto__隐式挂载。
![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4b03e889b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


##### new 手写版本二
考虑构造函数又返回值的情况：
* 如果构造函数返回一个对象，那么我们也返回这个对象
* 如上否则，就返回默认值
```js
  function objectFactory() {

      var obj = new Object(),//从Object.prototype上克隆一个对象

      Constructor = [].shift.call(arguments);//取得外部传入的构造器

      var F=function(){};
      F.prototype= Constructor.prototype;
      obj=new F();//指向正确的原型

      var ret = Constructor.apply(obj, arguments);//借用外部传入的构造器给obj设置属性

      return typeof ret === 'object' ? ret : obj;//确保构造器总是返回一个对象

  };
```
>call apply bind this 用法参考其他

#### 类式继承
```js
  function SuperClass() {
    this.superValue = true;
  }
  SuperClass.prototype.getSuperValue = function() {
    return this.superValue;
  }

  function SubClass() {
    this.subValue = false;
  }
  SubClass.prototype = new SuperClass();

  SubClass.prototype.getSubValue = function() {
    return this.subValue;
  }

  var instance = new SubClass();

  console.log(instance instanceof SuperClass)//true
  console.log(instance instanceof SubClass)//true
  console.log(SubClass instanceof SuperClass)//false
```

从我们之前介绍的 instanceof 的原理我们知道，第三个 console 如果这么写就返回 true 了console.log(SubClass.prototype instanceof SuperClass)

虽然实现起来清晰简洁，但是这种继承方式有两个缺点：

* 由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类
* 由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化

#### 构造函数继承
```js
  function SuperClass(name) {
    this.name = name; 
    this.books = ['Js','CSS'];
  }
  SuperClass.prototype.getBooks = function() {
      console.log(this.books);
  }
  function SubClass(name,time) {
    SuperClass.call(this,name);
    this.time = time;
  }
  SubClass.prototype = new SuperClass();

  SubClass.prototype.getTime = function() {
    console.log(this.time);
  }
```
SuperClass.call(this,id)当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型prototype，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法

#### 组合式继承
```js
  function SuperClass(name) {
    this.name = name; 
    this.books = ['Js','CSS'];
  }
  SuperClass.prototype.getBooks = function() {
      console.log(this.books);
  }
  function SubClass(name,time) {
    SuperClass.call(this,name);
    this.time = time;
  }
  SubClass.prototype = new SuperClass();

  SubClass.prototype.getTime = function() {
    console.log(this.time);
  }
```
如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个SuperClass的构造函数执行了两遍就感觉非常的不妥.

#### 原型式继承
```js
  function inheritObject(o) {
      //声明一个过渡对象
    function F() { }
    //过渡对象的原型继承父对象
    F.prototype = o;
    //返回过渡对象的实例，该对象的原型继承了父对象
    return new F();
  }
```
原型式继承大致的实现方式如上，是不是想到了我们new关键字模拟的实现？

其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象

```js
  var book = {
      name:'js book',
      likeBook:['css Book','html book']
  }
  var newBook = inheritObject(book);
  newBook.name = 'ajax book';
  newBook.likeBook.push('react book');
  var otherBook = inheritObject(book);
  otherBook.name = 'canvas book';
  otherBook.likeBook.push('node book');
  console.log(newBook,otherBook);
```
如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。

所以，我们还有下面的寄生式继承

#### 寄生式继承
```js
  var book = {
    name:'js book',
    likeBook:['html book','css book']
  }
  function createBook(obj) {
      //通过原型方式创建新的对象
    var o = new inheritObject(obj);
    // 拓展新对象
    o.getName = function(name) {
      console.log(name)
    }
    // 返回拓展后的新对象
    return o;
  }
```
其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。

#### 寄生组合式继承
回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承
而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。
```js
  function inheritObject(o) {
    //声明一个过渡对象
    function F() { }
    //过渡对象的原型继承父对象
    F.prototype = o;
    //返回过渡对象的实例，该对象的原型继承了父对象
    return new F();
  }

  function inheritPrototype(subClass,superClass) {
      // 复制一份父类的原型副本到变量中
    var p = inheritObject(superClass.prototype);
    // 修正因为重写子类的原型导致子类的constructor属性被修改
    p.constructor = subClass;
    // 设置子类原型
    subClass.prototype = p;
  }
```
组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。
我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的constructor属性指向的不是subClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起constructor属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。

```js
  function SuperClass(name) {
    this.name = name;
    this.books=['js book','css book'];
  }
  SuperClass.prototype.getName = function() {
    console.log(this.name);
  }
  function SubClass(name,time) {
    SuperClass.call(this,name);
    this.time = time;
  }
  inheritPrototype(SubClass,SuperClass);
  SubClass.prototype.getTime = function() {
    console.log(this.time);
  }
  var instance1 = new SubClass('React','2017/11/11')
  var instance2 = new SubClass('Js','2018/22/33');

  instance1.books.push('test book');

  console.log(instance1.books,instance2.books);
  instance2.getName();
  instance2.getTime();
```

![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4b28a1194?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.



### ES6 实现继承
1. class 可以理解为function,由于class本质还是一个function,因此它也会拥有一个的prototype属性，当new一个class时，会把class的porototype属性赋值给这个新对象的 __proto属性。
2. constructor 方法是默认添加的方法，在new一个对象时，自动调用该方法，constructor里面定义自己的属性。
3. 继承extends和super，**class 子类名 extends** 父类名实现继承，当然还得在constructor里面写上**super(父类的参数)**，意思就是在子类中获得父类的this指针，相当于**Animal.call(this)**

```js
  // es6继承
  class Animal {
    //构造函数，里面写上对象的属性
    constructor(props) {
      this.name = props.name || 'Unknown';
    }
    //方法写在后面
    eat() {//父类共有的方法
      console.log(this.name + " will eat pests.");
    }
  }

  //class继承
  class Bird extends Animal {
    //构造函数
    constructor(props,myAttribute) {//props是继承过来的属性，myAttribute是自己的属性
      //调用实现父类的构造函数
      super(props)//相当于获得父类的this指向
      this.type = props.type || "Unknown";//父类的属性，也可写在父类中
      this.attr = myAttribute;//自己的私有属性
    }

    fly() {//自己私有的方法
      console.log(this.name + " are friendly to people.");
    }
    myattr() {//自己私有的方法
      console.log(this.type+'---'+this.attr);
    }
  }

  //通过new实例化
    var myBird = new Bird({
      name: '小燕子',
      type: 'Egg animal'//卵生动物
    },'Bird class')
    myBird.eat()
    myBird.fly()
    myBird.myattr()
```
****

## 原型链
```js
  function Person(){}
  var person1 = new Person();
  console.log(person1.__proto__ === Person.prototype); // true
  console.log(Person.prototype.__proto__ === Object.prototype) //true
  console.log(Object.prototype.__proto__) //null

  Person.__proto__ == Function.prototype; //true
  console.log(Function.prototype)// function(){} (空函数)

  var num = new Array()
  console.log(num.__proto__ == Array.prototype) // true
  console.log( Array.prototype.__proto__ == Object.prototype) // true
  console.log(Array.prototype) // [] (空数组)
  console.log(Object.prototype.__proto__) //null

  console.log(Array.__proto__ == Function.prototype)// true
```
疑点解惑：
1. Object.__proto__ === Function.prototype // true
Object 是函数对象，是通过new Function()创建的，所以Object.__proto__指向Function.prototype。「所有函数对象的__proto__都指向Function.prototype」

2. Function.__proto__ === Function.prototype // true
Function 也是对象函数，也是通过new Function()创建，所以Function.__proto__指向Function.prototype。

> 自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物）
正如《道德经》里所说“无，名天地之始”。

3. **Function.prototype.__proto__ === Object.prototype //true**

> 其实这一点我也有点困惑，不过也可以试着解释一下。
Function.prototype是个函数对象，理论上他的__proto__应该指向 Function.prototype，就是他自己，自己指向自己，没有意义。
JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向Object.prototype。Object.prototype.__proto__ === null，保证原型链能够正常结束。

## 总结
* 原型和原型链是JS实现继承的一种模型。
* 原型链的形成是真正是靠__proto__ 而非prototype

我们再举个例子，
```js
   var animal = function(){};
  var dog = function(){};

  animal.price = 2000;
  dog.prototype = animal;
  var tidy = new dog();
  console.log(dog.price) //undefined
  console.log(tidy.price) // 2000
```
解释：
```js
   var dog = function(){};
  dog.prototype.price = 2000;
  var tidy = new dog();
  console.log(tidy.price); // 2000
  console.log(dog.price); //undefined

   var dog = function(){};
  var tidy = new dog();
  tidy.price = 2000;
  console.log(dog.price); //undefined
```
> 实例（tidy）和 原型对象（dog.prototype）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（tidy）与构造函数的原型对象（dog.prototype）之间，而不是存在于实例（tidy）与构造函数（dog）之间。

****

## 摘自JavaScript高级程序设计:
> 继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: **接口继承 和 实现继承**.接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的.

简单回顾下构造函数,原型和实例的关系:
>  每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.

JS对象圈子有这么个游戏规则
> 如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.

如果让原型对象指向另一个类型的实例…..有趣的事情便发生了.

即: constructor1.prototype = instance2

鉴于上述游戏规则生效,如果试图引用constructor1构造的实例instance1的某个属性p1:

1).首先会在instance1内部属性中找一遍;

2).接着会在instance1.__proto__(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;

3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.__proto__(constructor2.prototype)中寻找…直至Object的原型对象

> 搜索轨迹: instance1–> instance2 –> constructor2.prototype…–>Object.prototype

```js
  function Father(){
    this.property = true;
  }
  Father.prototype.getFatherValue = function(){
      return this.property;
  }
  function Son(){
      this.sonProperty = false;
  }
  //继承 Father
  Son.prototype = new Father();//Son.prototype被重写,导致Son.prototype.constructor也一同被重写
  Son.prototype.getSonVaule = function(){
      return this.sonProperty;
  }
  var instance = new Son();
  alert(instance.getFatherValue());//true
```

instance实例通过原型链找到了Father原型中的getFatherValue方法.

注意: 此时instance.constructor指向的是Father,这是因为Son.prototype中的constructor被重写的缘故.

### 确定原型和实例的关系
使用原型链后, 我们怎么去判断原型和实例的这种继承关系呢? 方法一般有两种.

> 第一种是使用 instanceof 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true. 以下几行代码就说明了这点.

```js
  alert(instance instanceof Object);//true
  alert(instance instanceof Father);//true
  alert(instance instanceof Son);//true
```

有鉴于此, 实践中很少会单独使用原型链.

为此,下面将有一些尝试以弥补原型链的不足.

### 借用构造函数
为解决原型链中上述两个问题, 我们开始使用一种叫做借用构造函数(constructor stealing)的技术(也叫经典继承).

**基本思想:即在子类型构造函数的内部调用超类型构造函数.**

```js
  function Father(){
    this.colors = ["red","blue","green"];
  }
  function Son(){
      Father.call(this);//继承了Father,且向父类型传递参数
  }
  var instance1 = new Son();
  instance1.colors.push("black");
  console.log(instance1.colors);//"red,blue,green,black"

  var instance2 = new Son();
  console.log(instance2.colors);//"red,blue,green" 可见引用类型值是独立的
```

很明显,借用构造函数一举解决了原型链的两大问题:

其一, 保证了原型链中引用类型值的独立,不再被所有实例共享;

其二, 子类型创建时也能够向父类型传递参数.

随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用.

### 组合继承
组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.

> 基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.

这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示.

```js
  function Father(name){
    this.name = name;
    this.colors = ["red","blue","green"];
  }
  Father.prototype.sayName = function(){
      alert(this.name);
  };
  function Son(name,age){
      Father.call(this,name);//继承实例属性，第一次调用Father()
      this.age = age;
  }
  Son.prototype = new Father();//继承父类方法,第二次调用Father()
  Son.prototype.sayAge = function(){
      alert(this.age);
  }
  var instance1 = new Son("louis",5);
  instance1.colors.push("black");
  console.log(instance1.colors);//"red,blue,green,black"
  instance1.sayName();//louis
  instance1.sayAge();//5

  var instance1 = new Son("zhai",10);
  console.log(instance1.colors);//"red,blue,green"
  instance1.sayName();//zhai
  instance1.sayAge();//10
```

组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象.

同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到.

### 原型继承
该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下:
> 在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例.

  ```js
    function object(o){
      function F(){}
      F.prototype = o;
      return new F();
    }
  ```

从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制.

  ```JS
    var person = {
      friends : ["Van","Louis","Nick"]
    };
    var anotherPerson = object(person);
    anotherPerson.friends.push("Rob");
    var yetAnotherPerson = object(person);
    yetAnotherPerson.friends.push("Style");
    alert(person.friends);//"Van,Louis,Nick,Rob,Style"
  ```
在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享.

在 ECMAScript5 中,通过新增 **object.create()** 方法规范化了上面的原型式继承.

**object.create()** 接收两个参数:

* 一个用作新对象原型的对象
* (可选的)一个为新对象定义额外属性的对象

  ```js
    var person = {
      friends : ["Van","Louis","Nick"]
    };
    var anotherPerson = Object.create(person);
    anotherPerson.friends.push("Rob");
    var yetAnotherPerson = Object.create(person);
    yetAnotherPerson.friends.push("Style");
    alert(person.friends);//"Van,Louis,Nick,Rob,Style"
  ```

  object.create() 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如:

  ```js
    var person = {
      name : "Van"
    };
    var anotherPerson = Object.create(person, {
        name : {
            value : "Louis"
        }
    });
    alert(anotherPerson.name);//"Louis"
  ```
  目前支持 Object.create() 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome.

  提醒: 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样.

### 寄生式继承
寄生式继承是与原型式继承紧密相关的一种思路， 同样是克罗克福德推而广之.

> 寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象. 如下.

  ```js
    function createAnother(original){
      var clone = object(original);//通过调用object函数创建一个新对象
      clone.sayHi = function(){//以某种方式来增强这个对象
          alert("hi");
      };
      return clone;//返回这个对象
    }
  ```
  这个例子中的代码基于person返回了一个新对象–anotherPerson. 新对象不仅具有 person 的所有属性和方法, 而且还被增强了, 拥有了sayH()方法.

  注意: 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.

  ### 寄生组合式继承
  前面讲过,组合继承是 JavaScript 最常用的继承模式; 不过, 它也有自己的不足. 组合继承最大的问题就是无论什么情况下,都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部. **寄生组合式继承就是为了降低调用父类构造函数的开销而出现的**

  > 其背后的基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数

  ```js
    function extend(subClass,superClass){
      var prototype = object(superClass.prototype);//创建对象
      prototype.constructor = subClass;//增强对象
      subClass.prototype = prototype;//指定对象
    }
  ```

  extend的高效率体现在它没有调用superClass构造函数,因此避免了在subClass.prototype上面创建不必要,多余的属性. 于此同时,原型链还能保持不变; 因此还能正常使用 instanceof 和 isPrototypeOf() 方法.

以上,寄生组合式继承,集寄生式继承和组合继承的优点于一身,是实现基于类型继承的最有效方法.

下面我们来看下extend的另一种更为有效的扩展.
  ```js
    function extend(subClass, superClass) {
      var F = function() {};
      F.prototype = superClass.prototype;
      subClass.prototype = new F(); 
      subClass.prototype.constructor = subClass;

      subClass.superclass = superClass.prototype;
      if(superClass.prototype.constructor == Object.prototype.constructor) {
        superClass.prototype.constructor = superClass;
      }
    }
  ```
  我一直不太明白的是为什么要 “new F()“, 既然extend的目的是将子类型的 prototype 指向超类型的 prototype,为什么不直接做如下操作呢?

  `subClass.prototype = superClass.prototype;//直接指向超类型prototype`

  显然, 基于如上操作, 子类型原型将与超类型原型共用, 根本就没有继承关系.

  ## 扩展
  person1.__proto__ 是什么？
  Person.__proto__ 是什么？
  Person.prototype.__proto__ 是什么？
  Object.__proto__ 是什么？
  Object.prototype__proto__ 是什么？

  第一题：
  因为 person1.__proto__ === person1 的构造函数.prototype
  因为 person1的构造函数 === Person
  所以 person1.__proto__ === Person.prototype

  第二题：
  因为 Person.__proto__ === Person的构造函数.prototype
  因为 Person的构造函数 === Function
  所以 Person.__proto__ === Function.prototype

  第三题：
  Person.prototype 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。
  因为一个普通对象的构造函数 === Object
  所以 Person.prototype.__proto__ === Object.prototype

  第四题，参照第二题，因为 Person 和 Object 一样都是构造函数

  第五题：
  Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。
  Object.prototype.__proto__ === null
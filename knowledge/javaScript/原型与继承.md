<!--
 * @Description: 
 * @Version: 3.0
 * @Autor: 冯帅
 * @Date: 2021-07-13 19:34:51
 * @LastEditors: 冯帅
 * @LastEditTime: 2021-07-14 23:52:49
-->
## 原型
1. 为什么 typeof 判断 null 是 Object 类型？
2. Function 和 Object 是什么关系？
3. new 关键字具体做了什么？手写实现。
4. prototype 和__proto__是什么关系？什么情况下相等？
5. ES5 实现继承有几种方式，优缺点是啥
6. ES6 如何实现一个类
7. ES6 extends 关键字实现原理是什么

![原型图](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F939316%2F201809%2F939316-20180927095306645-1975780154.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1628769155&t=dde49164112636162fa9b36cfbfd9ede)

* function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等
* function Object 就是一个 Object
* function Function 就是 Function
* 以上都是 function，所以 .__proto__都是Function.prototype
* 再次强调，String、Array、Number、Function、Object都是 function

### 函数对象和普通对象
老话说，万物皆对象。而我们都知道在 JavaScript 中，创建对象有好几种方式，比如对象字面量，或者直接通过构造函数 new 一个对象出来：

**都是对象，却存在着差异性**

其实在 JavaScript 中，我们将对象分为函数对象和普通对象。**所谓的函数对象，其实就是 JavaScript 的用函数来模拟的类实现**。JavaScript 中的 Object 和 Function 就是典型的函数对象。

```js
  function fun1(){};
  const fun2 = function(){};
  const fun3 = new Function('name','console.log(name)');

  const obj1 = {};
  const obj2 = new Object();
  const obj3 = new fun1();
  const obj4 = new new Function();


  console.log(typeof Object);//function
  console.log(typeof Function);//function
  console.log(typeof fun1);//function
  console.log(typeof fun2);//function
  console.log(typeof fun3);//function
  console.log(typeof obj1);//object
  console.log(typeof obj2);//object
  console.log(typeof obj3);//object
  console.log(typeof obj4);//object
```

上述代码中，obj1，obj2，obj3，obj4都是普通对象，fun1，fun2，fun3 都是 Function 的实例，也就是函数对象

所以可以看出，所有 Function 的实例都是函数对象，其他的均为普通对象，其中包括 Function 实例的实例。

![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4623fc5be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


**JavaScript 中万物皆对象，而对象皆出自构造（构造函数）。**

上图中，你疑惑的点是不是 **Function 和 new Function 的关系**。其实是这样子的：

`Function.__proto__ === Function.prototype//true`

#### __proto__
> 首先我们需要明确两点：
1️、 **__proto__和constructor是对象独有的。**
2、  **prototype属性是函数独有的**

**但是在 JavaScript 中，函数也是对象，所以函数也拥有__proto__和 constructor属性。**

**__proto__属性既不能被 for in 遍历出来，也不能被 Object.keys(obj) 查找出来。**

访问对象的 obj.__proto__ 属性，默认走的是 Object.prototype 对象上 __proto__ 属性的 get/set 方法。
```js
  Object.defineProperty(Object.prototype,'__proto__',{
    get(){
      console.log('get')
    }
  });

  ({}).__proto__;
  console.log((new Object()).__proto__);
```

这里我们需要知道的是，**__proto__是对象所独有的，并且__proto__是一个对象指向另一个对象**，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的__proto__属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的__proto__属性所指向的父类的父类上去查找。以此类推，知道找到 null。而这个查找的过程，也就构成了我们常说的**原型链**。

#### prototype
在规范里，prototype 被定义为：给其它对象提供共享属性的对象。prototype 自己也是对象，只是被用以承担某个职能罢了.

所有对象，都可以作为另一个对象的 prototype 来用。

![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4956afb78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

修改__proto__的关系图，我们添加了 prototype,**prototype是函数所独有的**它的作用就是包含可以给特定类型的所有实例提供共享的属性和方法。它的含义就是函数的远行对象,正如上图：nealyang.__proto__ === Person.prototype。 任何函数在创建的时候，都会默认给该函数添加 prototype 属性.

#### constructor
**constructor属性也是对象所独有的，它是一个对象指向一个函数，这个函数就是该对象的构造函数。**

注意，**每一个对象都有其对应的构造函数，本身或者继承而来。单从constructor这个属性来讲，只有prototype对象才有**。每个函数在创建的时候，JavaScript 会同时创建一个该函数对应的prototype对象，**而函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其对应的构造函数。**

唯一特殊的可能就是我开篇抛出来的一个问题。**JavaScript 原型的老祖宗：Function。它是它自己的构造函数。所以Function.prototype === Function.__proto__。**

![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4a315ac95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

其中 constructor 属性，**虚线表示继承而来的 constructor 属性**

### typeof && instanceof 原理
[MDN文档typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)

#### 基本用法
一般被用于来判断一个变量的类型。我们**可以使用 typeof 来判断number、undefined、symbol、string、function、boolean、object 这七种数据类型**。但是遗憾的是，typeof 在判断 object 类型时候，有些许的尴尬。它并不能明确的告诉你，该 object 属于哪一种 object。

```js
  let s = new String('abc');
  typeof s === 'object'// true
  typeof null;//"object"
```

#### 原理浅析
要想弄明白为什么 typeof 判断 null 为 object，其实需要从js 底层如何存储变量类型来说其。虽然说，这是 JavaScript 设计的一个 bug。

在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 "object"。曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但**被拒绝了**。该提案会导致 typeof null === 'null'。

js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息：

* 1：整数
* 110：布尔
* 100：字符串
* 010：浮点数
* 000：对象

但是，对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的：

* null：所有机器码均为0
* undefined：用 −2^30 整数来表示

所以在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。

#### instanceof
instanceof 和 typeof 非常的类似。**instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上**。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。

#### 基本用法

```js
  // 定义构造函数
  function C(){} 
  function D(){} 

  var o = new C();


  o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype


  o instanceof D; // false，因为 D.prototype 不在 o 的原型链上

  o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
  C.prototype instanceof Object // true，同上

  C.prototype = {};
  var o2 = new C();

  o2 instanceof C; // true

  o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.

  D.prototype = new C(); // 继承
  var o3 = new D();
  o3 instanceof D; // true
  o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上
```

如上，是 **instanceof 的基本用法，它可以判断一个实例是否是其父类型或者祖先类型的实例。**

```js
  console.log(Object instanceof Object);//true 
  console.log(Function instanceof Function);//true 
  console.log(Number instanceof Number);//false 
  console.log(String instanceof String);//false 

  console.log(Function instanceof Object);//true 

  console.log(Foo instanceof Function);//true 
  console.log(Foo instanceof Foo);//false
```
为什么 Object 和 Function instanceof 自己等于 true，而其他类 instanceof 自己却又不等于 true 呢？如何解释？
要想从根本上了解 instanceof 的奥秘，需要从两个方面着手：
1. 语言规范中是如何定义这个运算符的。
2. JavaScript 原型继承机制。

#### 原理浅析
经过上述的分析，相比大家对这种经典神图已经不那么陌生了吧，那咱就对着这张图来聊聊 instanceof

![原型图](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F939316%2F201809%2F939316-20180927095306645-1975780154.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1628769155&t=dde49164112636162fa9b36cfbfd9ede)

这里，我直接将规范定义翻译为 JavaScript 代码如下：
```js
  function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
  var O = R.prototype;// 取 R 的显示原型
  L = L.__proto__;// 取 L 的隐式原型
  while (true) { 
    if (L === null) 
      return false; 
    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true 
      return true; 
    L = L.__proto__; 
  } 
  }
```

所以如上原理，加上上文解释的原型相关知识，我们再来解析下为什么Object 和 Function instanceof 自己等于 true。

* Object instanceof Object
```js
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  ObjectL = Object, ObjectR = Object; 
  // 下面根据规范逐步推演
  O = ObjectR.prototype = Object.prototype 
  L = ObjectL.__proto__ = Function.prototype 
  // 第一次判断
  O != L 
  // 循环查找 L 是否还有 __proto__ 
  L = Function.prototype.__proto__ = Object.prototype 
  // 第二次判断
  O == L 
  // 返回 true
```

* Function instanceof Function
```js
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  FunctionL = Function, FunctionR = Function; 
  // 下面根据规范逐步推演
  O = FunctionR.prototype = Function.prototype 
  L = FunctionL.__proto__ = Function.prototype 
  // 第一次判断
  O == L 
  // 返回 true
```

* Foo instanceof Foo
```js
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  FooL = Foo, FooR = Foo; 
  // 下面根据规范逐步推演
  O = FooR.prototype = Foo.prototype 
  L = FooL.__proto__ = Function.prototype 
  // 第一次判断
  O != L 
  // 循环再次查找 L 是否还有 __proto__ 
  L = Function.prototype.__proto__ = Object.prototype 
  // 第二次判断
  O != L 
  // 再次循环查找 L 是否还有 __proto__ 
  L = Object.prototype.__proto__ = null 
  // 第三次判断
  L == null 
  // 返回 false
```

### ES5 中的继承实现方式
在继承实现上，工业聚大大在他的原型文章中，将原型继承分为两大类，显式继承和隐式继承。感兴趣的可以点击文末参考链接查看。

#### new 关键字
一个例子看下new 关键字都干了啥

```js
  function Person(name,age){
    this.name = name;
    this.age = age;
    
    this.sex = 'male';
  }

  Person.prototype.isHandsome = true;

  Person.prototype.sayName = function(){
    console.log(`Hello , my name is ${this.name}`);
  }

  let handsomeBoy = new Person('Nealyang',25);

  console.log(handsomeBoy.name) // Nealyang
  console.log(handsomeBoy.sex) // male
  console.log(handsomeBoy.isHandsome) // true

  handsomeBoy.sayName(); // Hello , my name is Nealyang
```
从上面的例子我们可以看到：
* 访问到 Person 构造函数里的属性
* 访问到 Person.prototype 中的属性

##### new 手写版本一
```js
  function objectFactory() {

      const obj = new Object(),//从Object.prototype上克隆一个对象

      Constructor = [].shift.call(arguments);//取得外部传入的构造器

      const F=function(){};
      F.prototype= Constructor.prototype;
      obj=new F();//指向正确的原型

      Constructor.apply(obj, arguments);//借用外部传入的构造器给obj设置属性

      return obj;//返回 obj
  };
```
* 用new Object() 的方式新建了一个对象 obj
* 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
* 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性
* 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性
* 返回 obj

下面我们来测试一下：
```js
  function Person(name,age){
    this.name = name;
    this.age = age;
    
    this.sex = 'male';
  }

  Person.prototype.isHandsome = true;

  Person.prototype.sayName = function(){
    console.log(`Hello , my name is ${this.name}`);
  }

  function objectFactory() {

      let obj = new Object(),//从Object.prototype上克隆一个对象

      Constructor = [].shift.call(arguments);//取得外部传入的构造器
      
      console.log({Constructor})

      const F=function(){};
      F.prototype= Constructor.prototype;
      obj=new F();//指向正确的原型

      Constructor.apply(obj, arguments);//借用外部传入的构造器给obj设置属性

      return obj;//返回 obj

  };

  let handsomeBoy = objectFactory(Person,'Nealyang',25);

  console.log(handsomeBoy.name) // Nealyang
  console.log(handsomeBoy.sex) // male
  console.log(handsomeBoy.isHandsome) // true

  handsomeBoy.sayName(); // Hello , my name is Nealyang
```
注意上面我们没有直接修改 obj 的__proto__隐式挂载。
![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4b03e889b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


##### new 手写版本二
考虑构造函数又返回值的情况：
* 如果构造函数返回一个对象，那么我们也返回这个对象
* 如上否则，就返回默认值
```js
  function objectFactory() {

      var obj = new Object(),//从Object.prototype上克隆一个对象

      Constructor = [].shift.call(arguments);//取得外部传入的构造器

      var F=function(){};
      F.prototype= Constructor.prototype;
      obj=new F();//指向正确的原型

      var ret = Constructor.apply(obj, arguments);//借用外部传入的构造器给obj设置属性

      return typeof ret === 'object' ? ret : obj;//确保构造器总是返回一个对象

  };
```
>call apply bind this 用法参考其他

#### 类式继承
```js
  function SuperClass() {
    this.superValue = true;
  }
  SuperClass.prototype.getSuperValue = function() {
    return this.superValue;
  }

  function SubClass() {
    this.subValue = false;
  }
  SubClass.prototype = new SuperClass();

  SubClass.prototype.getSubValue = function() {
    return this.subValue;
  }

  var instance = new SubClass();

  console.log(instance instanceof SuperClass)//true
  console.log(instance instanceof SubClass)//true
  console.log(SubClass instanceof SuperClass)//false
```

从我们之前介绍的 instanceof 的原理我们知道，第三个 console 如果这么写就返回 true 了console.log(SubClass.prototype instanceof SuperClass)

虽然实现起来清晰简洁，但是这种继承方式有两个缺点：

* 由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类
* 由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化

#### 构造函数继承
```js
  function SuperClass(name) {
    this.name = name; 
    this.books = ['Js','CSS'];
  }
  SuperClass.prototype.getBooks = function() {
      console.log(this.books);
  }
  function SubClass(name,time) {
    SuperClass.call(this,name);
    this.time = time;
  }
  SubClass.prototype = new SuperClass();

  SubClass.prototype.getTime = function() {
    console.log(this.time);
  }
```
SuperClass.call(this,id)当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型prototype，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法

#### 组合式继承
```js
  function SuperClass(name) {
    this.name = name; 
    this.books = ['Js','CSS'];
  }
  SuperClass.prototype.getBooks = function() {
      console.log(this.books);
  }
  function SubClass(name,time) {
    SuperClass.call(this,name);
    this.time = time;
  }
  SubClass.prototype = new SuperClass();

  SubClass.prototype.getTime = function() {
    console.log(this.time);
  }
```
如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个SuperClass的构造函数执行了两遍就感觉非常的不妥.

#### 原型式继承
```js
  function inheritObject(o) {
      //声明一个过渡对象
    function F() { }
    //过渡对象的原型继承父对象
    F.prototype = o;
    //返回过渡对象的实例，该对象的原型继承了父对象
    return new F();
  }
```
原型式继承大致的实现方式如上，是不是想到了我们new关键字模拟的实现？

其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象

```js
  var book = {
      name:'js book',
      likeBook:['css Book','html book']
  }
  var newBook = inheritObject(book);
  newBook.name = 'ajax book';
  newBook.likeBook.push('react book');
  var otherBook = inheritObject(book);
  otherBook.name = 'canvas book';
  otherBook.likeBook.push('node book');
  console.log(newBook,otherBook);
```
如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。

所以，我们还有下面的寄生式继承

#### 寄生式继承
```js
  var book = {
    name:'js book',
    likeBook:['html book','css book']
  }
  function createBook(obj) {
      //通过原型方式创建新的对象
    var o = new inheritObject(obj);
    // 拓展新对象
    o.getName = function(name) {
      console.log(name)
    }
    // 返回拓展后的新对象
    return o;
  }
```
其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。

#### 寄生组合式继承
回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承
而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。
```js
  function inheritObject(o) {
    //声明一个过渡对象
    function F() { }
    //过渡对象的原型继承父对象
    F.prototype = o;
    //返回过渡对象的实例，该对象的原型继承了父对象
    return new F();
  }

  function inheritPrototype(subClass,superClass) {
      // 复制一份父类的原型副本到变量中
    var p = inheritObject(superClass.prototype);
    // 修正因为重写子类的原型导致子类的constructor属性被修改
    p.constructor = subClass;
    // 设置子类原型
    subClass.prototype = p;
  }
```
组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。
我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的constructor属性指向的不是subClass子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起constructor属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。

```js
  function SuperClass(name) {
    this.name = name;
    this.books=['js book','css book'];
  }
  SuperClass.prototype.getName = function() {
    console.log(this.name);
  }
  function SubClass(name,time) {
    SuperClass.call(this,name);
    this.time = time;
  }
  inheritPrototype(SubClass,SuperClass);
  SubClass.prototype.getTime = function() {
    console.log(this.time);
  }
  var instance1 = new SubClass('React','2017/11/11')
  var instance2 = new SubClass('Js','2018/22/33');

  instance1.books.push('test book');

  console.log(instance1.books,instance2.books);
  instance2.getName();
  instance2.getTime();
```

![](https://user-gold-cdn.xitu.io/2019/10/31/16e1f9f4b28a1194?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.

### ES6 类的实现原理














****
### 摘自JavaScript高级程序设计:
> 继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: **接口继承 和 实现继承**.接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的.